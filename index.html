/**
 * Main.gs - çµ‚æ¥µä¿®å¾©æ•´åˆç‰ˆ
 */
const CONFIG = {
  API_KEY: 'AIzaSyASUkyl5TP2kxKqkZFVY6qlHWfjro023OY', // ä½ çš„ Gemini API Key
  SHEET_NAME: 'WordBank',
  SHEET_ARTICLES: 'ArticleBank',
  // ä¿®æ­£ï¼šå¿…é ˆä½¿ç”¨ raw åŸå§‹é€£çµï¼ŒAI æ‰èƒ½ä¸‹è¼‰
  REF_AUDIO_URL: "https://raw.githubusercontent.com/kiteyoung8/my-voice-assets/main/01%E6%B0%91%E8%88%AA%E6%92%AD%E9%9F%B3%E7%A8%BF%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%88%E5%B8%B8%E9%80%9F%E6%9C%97%E8%AF%BB%EF%BC%89.mp3",
  // ä¿®æ­£ï¼šæ›´æ›ç‚ºç›®å‰ç©©å®šé‹è¡Œçš„ Space æ¥å£
  TTS_API_URL: "https://hasanbasbunar-voice-cloning-xtts-v2.hf.space/api/predict"
};

function doPost(e) {
  const output = ContentService.createTextOutput();
  try {
    const params = JSON.parse(e.postData.contents);
    let result = {};
    switch (params.action) {
      case 'generate': result = handleTopicGeneration(params.topic, params.level, params.len, params.scenario); break;
      case 'tts': result = handleTTS(params.text, params.version); break;
      case 'translate': result = handleWordTranslation(params.word, params.context); break;
      case 'getVocab': result = getVocabularyList(params.userId); break;
      case 'saveVocab': result = saveVocabulary(params.userId, params.word, params.ipa, params.def, params.ctx, params.ctxChn); break;
      case 'delVocab': result = deleteVocabulary(params.userId, params.id); break;
      case 'saveArticle': result = saveArticle(params.userId, params.title, params.content, params.contentChn); break;
      case 'getArticles': result = getArticleList(params.userId); break;
      case 'delArticle': result = deleteArticle(params.userId, params.id); break;
      default: result = { status: 'error', message: 'æœªçŸ¥æ“ä½œ' };
    }
    output.setContent(JSON.stringify(result));
  } catch (err) {
    output.setContent(JSON.stringify({ status: 'error', message: err.toString() }));
  }
  return output.setMimeType(ContentService.MimeType.JSON);
}

// ğŸ™ï¸ èªéŸ³åˆæˆï¼šå°æ¥æ–°æ¥å£æ ¼å¼
function handleTTS(text, version) {
  let processedText = text;
  if (version === 'B_Philosophical') processedText = text.replace(/\. /g, "... ");
  const payload = { "data": [processedText, "en", CONFIG.REF_AUDIO_URL, null, false, "Stay on topic", "Neutral", false] };
  const options = { "method": "post", "contentType": "application/json", "payload": JSON.stringify(payload), "muteHttpExceptions": true };
  const res = UrlFetchApp.fetch(CONFIG.TTS_API_URL, options);
  const json = JSON.parse(res.getContentText());
  if (json.data && json.data[0]) return { status: 'success', audioUrl: json.data[0].url };
  throw new Error("AI å—“å­æš«ä¸å¯ç”¨ï¼Œè«‹ç¢ºèª Space æ˜¯å¦é‹è¡Œä¸­");
}

// ğŸ§  AI ç”Ÿæˆï¼šä½¿ç”¨ç©©å®šæ¨¡å‹
function callGemini(prompt, useSearch) {
  const model = "gemini-1.5-flash"; 
  const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${CONFIG.API_KEY}`;
  const payload = { contents: [{ parts: [{ text: prompt }] }] };
  const res = UrlFetchApp.fetch(url, { method: "post", contentType: "application/json", payload: JSON.stringify(payload) });
  const json = JSON.parse(res.getContentText());
  const txt = json.candidates[0].content.parts[0].text;
  const jsonMatch = txt.match(/\{[\s\S]*\}/);
  return JSON.parse(jsonMatch[0]);
}

// (å…¶é¤˜è³‡æ–™åº«å‡½å¼è«‹ä¿ç•™åŸæœ¬ code)
